### Random : 
multiple requests to the same object will be cached based on a ==key==.

the key can be : 
HOST  , User Agent , the url , the parametrs  , just test them to know . 

---
the objective of web cache poisning is to send a request that causes a harmful response that gets saved in the cache and served to other users . 

impact : 
- information disclosure .
- stored xss .
- DOS hhhhhh .
- Unauthenticated access to sensitive pages .
- password reset attacks .

---

load balencer = proxy server

another server : server caching

---




get /endpoint1 ( used and keyd)
x-original-url : /endpoint2 (valid one) (used and unkeyd)


cached => waw


===============

exploit internal cache using x-original-url : ( drupal framework)
the website has no external cache , but has internal 

gat /endpoint1?search=yahia (unused and unkeyd)
x-original-url : /endpoint2?search=oussama (valid one) (used and keyd)


result : oussama ( cached for yahia)

==============

in any drupal request that 302 , 

if you add a paremter : destination , you will go to that 

is open redirect , and i easy bypass

![[Pasted image 20250718185340.png]]
#### Headers : 

##### Cache-Control : 

| Directive                        | Description                                                        |
| -------------------------------- | ------------------------------------------------------------------ |
| `public`                         | The response **can be cached** by any cache (browser, CDN, proxy). |
| `private`                        | Only the **browser** may cache the response.                       |
| `no-store`                       | Don't store the response in **any cache**. Most secure.            |
| `no-cache`                       | Store it, but **validate with the origin server** before using.    |
| `max-age=seconds`                | Cache the response for `X` seconds.                                |
| `s-maxage=seconds`               | Like `max-age` but **only for shared caches** (e.g., CDNs).        |
| `must-revalidate`                | Once stale, **must revalidate** with origin before use.            |
| `proxy-revalidate`               | Like `must-revalidate`, but **only for shared caches**.            |
| `immutable`                      | Response **never changes**, no revalidation needed.                |
| `stale-while-revalidate=seconds` | Serve stale content while revalidating in the background.          |
| `stale-if-error=seconds`         | Serve stale content if the origin server errors out.               |

##### Vary : 

| Header                  | Behavior                                                  |
| ----------------------- | --------------------------------------------------------- |
| `Vary: Accept-Encoding` | Cache separate versions for gzip, br, deflate, etc.       |
| `Vary: User-Agent`      | Serve different responses for different browsers/devices. |
| `Vary: Authorization`   | Often used when responses vary based on logged-in state.  |
| `Vary: Origin`          | Useful in CORS setups (cache per origin).                 |
| `Vary: Accept-Language` | Responses vary by user language preference.               |

unkeyd headers : headers that can not see , between proxy and server

X-Forwerded-For : 8.8.8.8

user , cache server , the big server .

user talk with cache server only , and ther cache server talk with the big server like he is the user .
X-Forwerded-For is a unkeyd haeder that the cache server add at the request telling the big server his ip to talk with him .

---


if the server accept just get and post , and you wanna put , delete ......... , try this :

X-HTTP-Method
X-HTTP-Method-Overide
X-Method-Overide

---
### Notes : 

multiple requests to the same object will be cached based on a ==key==.
Components of the request that are not included in the cache key are said to be "unkeyed".

Genraly , we have 3 steps : 
-  Identify and evaluate unkeyed inputs . 
-  Elicit a harmful response from the back-end server .
-  Get the response cached . 


we will use the unkeyed inputs to make the impact ( all the inputs that not used in cache )
you can find them manual or using **ParamMiner**

**it is important to make sure that your requests all have a unique cache key**


---------------------------------------------------

### PORTSWIGGER LABS : 

###### ## Using web cache poisoning to deliver an XSS attack : 
unkeyed input is reflected in a cacheable response without proper sanitization.


###### ## Using web cache poisoning to exploit unsafe handling of resource imports : 

importing resources , like JavaScript files .

###### ## Using web cache poisoning to exploit cookie-handling vulnerabilities : 

###### ## Using multiple headers to exploit web cache poisoning vulnerabilities : 

just fuzz in headers and make a malicious response , 

###### ## Parameter cloaking : 

HPP : http parametrt polution , amazing idea 

find the wright js file to poisine 

we see a parameter **callback=** , it call a js function , we try to chaneg it , but is a cache key .
we fuzz for unkeyd parameters , we find **utm_content=** , we get it a value , and we steal see HIT , so it a unkeyd header .

the final : ?**callback=hello&utm_content=foo;callback=alert(1)**


###### ## fat GET request : 

by adding parameters in the body of get request .

###### ## URL normalization :

poisin an error message that we escalate it to an self xss , when you inject the payload to the url , it will be url encoded , but when we injecte it to the request in the repaeter , is work .


###### ## Internal cache poisoning : 

while testing the app , we notice that is support x-forwarded-for header , but the suprise is a keyed header bu the external cache , but when we remove it , we steal see the link in the response , so => internal cache , and the header is unkeyd for it , so we will exploit it .

think like we have 2 caching servers , hada makan .








---

   
---

### Resources : 


| Resource                                                                                                                | isDone                                  |
| ----------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| https://medium.com/@0xAwali/beyond-web-caching-vulnerabilities-c617d8cdbb85                                             |                                         |
| https://www.youtube.com/watch?v=czDfMWBsIKw&t=45s                                                                       |                                         |
| https://portswigger.net/research/responsible-denial-of-service-with-web-cache-poisoning                                 |                                         |
| https://bxmbn.medium.com/                                                                                               | yes                                     |
| https://nokline.github.io/bugbounty/2022/09/02/Glassdoor-Cache-Poisoning.html                                           | yes                                     |
| https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack.pdf                                  |                                         |
| https://youst.in/posts/cache-poisoning-at-scale/                                                                        | yes ( but recommended to read it again) |
| https://developers.cloudflare.com/cache/about/cache-deception-armor/                                                    |                                         |
| https://medium.com/@zhero_                                                                                              |                                         |
| https://medium.com/legionhunters/advanced-web-cache-poisoning-techniques-part-2-tools-methods-and-exploits-d35619d4bd75 |                                         |
| read cloudflare , akami , nginx documentation                                                                           |                                         |
| practical web cache poisining by jams katel ( vidio )                                                                   | yes                                     |
| https://book.hacktricks.wiki/en/pentesting-web/cache-deception/index.html                                               | yes                                     |
| https://portswigger.net/research/smashing-the-state-machine                                                             |                                         |
| https://portswigger.net/research/gotta-cache-em-all                                                                     |                                         |
| https://medium.com/@ltidi/race-condition-leads-to-cache-poisoning-77bdfb9483fd                                          |                                         |
| https://portswigger.net/research/web-cache-entanglement (vidio)                                                         | yes (but 3awdo kach nhar)               |
| https://enumerated.wordpress.com/2020/08/05/the-case-of-the-missing-cache-keys/                                         |                                         |
| https://cpdos.org/                                                                                                      |                                         |




---
### My Tips : 

- see in the response ( in the code ) if you see the value of the HOST header .
- X-Cache: hit   : means that the response get it from the cache .
- Vary : is a response header , ensures that the cached response is based on that hedaers 
      example : Vary: User-Agent
    so now the  User-Agent is a key header , the cached response is based in it ( + the other headers like HOST maybe and ofcourse the URL)

- Pragma: x-get-cache-key ; will give you the keys used in caching
- paramminer => guess get parameters , maybe is unkeyd parameter and it reflected in the response => bom bug
- dont believe headers , like no-cache , just try the bug and see ( i mean like inject xss and see if it cached)
- inject i referer header , and see if it reflected .
- if a url dont be cached , try to add .js , .css and see if it cached , after that xssssssss
- if the ip is reflectd in the response => x-forwarded-for : payload
- .woff2 is a good extension for web cache seception
- if you find a self xss in endpoint that not cahced , and you have an endpoint that cached , try path traversel to chain them to get bbbbooommmm



==if you dont stop F and P , you will make noyhing==



---
target : servicenow use akamai 

---

## # Web Cache Entanglement: Novel Pathways to Poisoning 
#### unkeyd port : 

host : redacted.com
301 : location: redacted.com            = miss

host : redacted.com:1
301 : location: redacted.com:1          = hit

and bom , we have DOS 

#### unkeyd query : 


when the query is unkeyd , we will search about the cache key , by adding cache busters in some headers ( like origin , cookie , ............)

another method is change the METHOD to : PURGE/FASTLYPURGE

**Path Normalization :**
Nginx : // , /./ , %2F
PHP : /index.php/xyz
.NET : /(A(xyz))/

#### redirect DoS gadget : 

any redurect response 

add a query paramter to the path , with a very long string in the value , will make an error 

( add a cache buster)

Transormation : is a very good technique to bypass some restriction 

url encode in the request => normal in the response : query in the request not equal query in the response 

#### cache parameter cloaking : 

in akamai : /?yahia=yahia&oussama=oussama    ==  /?yahia=yahia?oussama=oussama

---


#### **Akamai** : 

##### No login page : 
send the first request to repeater
ensure that is cached
add illegal headers , like : \\ \:      =>bad request cached => DOS

##### With login page : 
search for web cache deception
search for endpoint that leak sensitive data 
add extension to the end of endpoint , like   : /api/user/.js  , /xxxx/xxxxxx/;.js


#### **Cloudflare** : 

---

#### race condition to web cache poisiing => DOS : 
















------










